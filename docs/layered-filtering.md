# 分层文本过滤机制说明

## 🎯 过滤策略

为了提高TTS处理效率和准确性，我们实现了**分层过滤机制**：

### 第一层：快速过滤（性能优化）
在文本预处理之前，快速识别并跳过明显的标记行：

```go
// 快速过滤明显的标记行（仅针对行首的标记）
if strings.HasPrefix(trimmedLine, "## ") ||
    strings.HasPrefix(trimmedLine, "### ") ||
    strings.HasPrefix(trimmedLine, "#### ") ||
    strings.HasPrefix(trimmedLine, "** ") ||
    strings.HasPrefix(trimmedLine, "| ") ||
    trimmedLine == "##" ||
    trimmedLine == "###" ||
    trimmedLine == "####" ||
    trimmedLine == "**" ||
    trimmedLine == "***" ||
    strings.HasPrefix(trimmedLine, "-- ") ||
    strings.HasPrefix(trimmedLine, "-----") {
    continue // 跳过标记行
}
```

### 第二层：智能验证（准确性保证）
使用文本预处理器进行详细分析：

```go
// 使用文本处理器进行详细预处理和验证
if !textProcessor.IsValidTextForTTS(line) {
    continue // 跳过无效行
}
```

### 第三层：文本处理（质量优化）
对有效文本进行预处理以优化TTS效果：

```go
// 处理文本以优化TTS效果
processedText := textProcessor.ProcessText(line)
if processedText == "" {
    continue
}
```

## 📊 过滤效果对比

### 快速过滤的行（第一层）
- `## 这是Markdown标题` ✅ 跳过
- `### 另一个标题` ✅ 跳过  
- `** 这是粗体标记行` ✅ 跳过
- `| 这是表格行` ✅ 跳过
- `-- 这是分隔线` ✅ 跳过
- `-----` ✅ 跳过
- `###` ✅ 跳过
- `***` ✅ 跳过

### 通过快速过滤但需要进一步处理的行
- `**正常的粗体文本**不应该被过滤` → `正常的粗体文本不应该被过滤`
- `\*\*转义字符\*\*应该被正确处理` → `转义字符应该被正确处理`
- `AI Agent可以automatically处理various任务` → `AI Agent 可以 automatically 处理 various 任务`

## 🚀 性能优势

1. **避免不必要的处理**：明显的标记行无需进入复杂的文本预处理流程
2. **保持准确性**：包含有效内容的行仍会进行完整处理
3. **提高效率**：减少正则表达式匹配和字符串处理操作

## 🔧 实现细节

### 处理流程
1. **空行检查** → 跳过空行
2. **快速标记过滤** → 跳过明显的Markdown标记行
3. **智能验证** → 检查文本是否适合TTS
4. **文本预处理** → 优化TTS效果
5. **最终验证** → 确保处理后的文本有效

### 关键设计原则
- **精确匹配**：只过滤确定的标记模式，避免误杀
- **空格敏感**：区分 `** ` (标记) 和 `**文本**` (格式)
- **上下文保护**：保留有意义的内容，只移除纯标记

## 📈 效果统计

测试文件: `test_layered_filtering.txt` (25行)
- **总行数**: 25
- **有效行数**: 8 (32%)
- **快速过滤**: 10行 (40%)
- **详细过滤**: 7行 (28%)

### 典型处理示例

```
输入: \*\*代理（Agents）\*\*能基于用户输入自主决策执行流程，具备能力选择工具、判断是否需要多轮调用。
第一层: 通过（不是标记行）
第二层: 通过（包含有效内容）
第三层: 转义字符 → Markdown → 结果
输出: 代理（Agents）能基于用户输入自主决策执行流程，具备能力选择工具、判断是否需要多轮调用。
```

这种分层机制确保了处理的高效性和准确性，既避免了不必要的计算，又保证了文本质量。
